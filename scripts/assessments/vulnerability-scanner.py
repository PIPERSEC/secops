#!/usr/bin/env python3
"""
Comprehensive Vulnerability Scanner and Security Assessment Tool

This script performs automated vulnerability scanning using multiple
security testing frameworks based on OWASP and NIST best practices.

Author: Security Operations Team
Version: 1.0
References:
- OWASP Web Security Testing Guide: https://owasp.org/www-project-web-security-testing-guide/
- OWASP Vulnerability Scanning Tools: https://owasp.org/www-community/Vulnerability_Scanning_Tools
- NIST Cybersecurity Framework: https://www.nist.gov/cyberframework
"""

import argparse
import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import os

try:
    import bandit
    from bandit.core import manager as bandit_manager
except ImportError:
    print("âš  Bandit not installed. Install with: pip install bandit")

try:
    import safety
except ImportError:
    print("âš  Safety not installed. Install with: pip install safety")

class Colors:
    """ANSI color codes for terminal output"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner supporting multiple scan types
    """

    def __init__(self, target: str, output_dir: str = "scan_results"):
        self.target = target
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.results = {
            'scan_info': {
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'scanner_version': '1.0'
            },
            'findings': {
                'critical': [],
                'high': [],
                'medium': [],
                'low': [],
                'info': []
            },
            'statistics': {
                'total_vulnerabilities': 0,
                'by_severity': {}
            }
        }

    def print_banner(self):
        """Print scanner banner"""
        banner = f"""
{Colors.OKCYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘   Comprehensive Vulnerability Scanner                            â•‘
â•‘   Based on OWASP and NIST Best Practices                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Colors.ENDC}

Target: {Colors.BOLD}{self.target}{Colors.ENDC}
Scan Start: {Colors.BOLD}{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{Colors.ENDC}
        """
        print(banner)

    def scan_code_security(self, code_path: str) -> Dict:
        """
        Scan Python code for security vulnerabilities using Bandit

        OWASP Reference: Static Application Security Testing (SAST)
        NIST CSF: Detect (DE.CM)
        """
        print(f"\n{Colors.HEADER}[*] Running Static Application Security Testing (SAST){Colors.ENDC}")
        print(f"{Colors.OKBLUE}    Using Bandit - Python Security Scanner{Colors.ENDC}")

        try:
            # Run Bandit
            result = subprocess.run(
                ['bandit', '-r', code_path, '-f', 'json', '-o',
                 str(self.output_dir / 'bandit_results.json')],
                capture_output=True,
                text=True
            )

            # Parse results
            if (self.output_dir / 'bandit_results.json').exists():
                with open(self.output_dir / 'bandit_results.json', 'r') as f:
                    bandit_results = json.load(f)

                findings = bandit_results.get('results', [])

                for finding in findings:
                    severity = finding.get('issue_severity', 'UNKNOWN').upper()
                    self.add_finding(
                        severity=self._map_severity(severity),
                        category='Code Security',
                        title=finding.get('issue_text', 'Unknown Issue'),
                        description=f"File: {finding.get('filename')} Line: {finding.get('line_number')}",
                        recommendation=finding.get('issue_cwe', {}).get('message', 'Review code'),
                        reference='OWASP ASVS 4.0',
                        cwe=finding.get('issue_cwe', {}).get('id', 'N/A')
                    )

                print(f"{Colors.OKGREEN}    âœ“ Found {len(findings)} potential issues{Colors.ENDC}")
                return {'status': 'completed', 'findings': len(findings)}

        except FileNotFoundError:
            print(f"{Colors.WARNING}    âš  Bandit not found. Install with: pip install bandit{Colors.ENDC}")
            return {'status': 'skipped', 'reason': 'Bandit not installed'}
        except Exception as e:
            print(f"{Colors.FAIL}    âœ— Error running Bandit: {e}{Colors.ENDC}")
            return {'status': 'error', 'message': str(e)}

    def scan_dependencies(self, requirements_file: Optional[str] = None) -> Dict:
        """
        Scan Python dependencies for known vulnerabilities using Safety

        OWASP Reference: Software Composition Analysis (SCA)
        NIST CSF: Identify (ID.RA)
        """
        print(f"\n{Colors.HEADER}[*] Running Software Composition Analysis (SCA){Colors.ENDC}")
        print(f"{Colors.OKBLUE}    Using Safety - Dependency Vulnerability Scanner{Colors.ENDC}")

        try:
            cmd = ['safety', 'check', '--json']
            if requirements_file:
                cmd.extend(['--file', requirements_file])

            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.stdout:
                try:
                    vulnerabilities = json.loads(result.stdout)

                    for vuln in vulnerabilities:
                        self.add_finding(
                            severity='HIGH',
                            category='Dependency Vulnerability',
                            title=f"{vuln[0]} - {vuln[1]}",
                            description=vuln[2],
                            recommendation=f"Update to version {vuln[3]} or higher",
                            reference=f"CVE: {vuln.get(4, 'N/A')}",
                            cwe='CWE-1035'
                        )

                    print(f"{Colors.OKGREEN}    âœ“ Found {len(vulnerabilities)} vulnerable dependencies{Colors.ENDC}")
                    return {'status': 'completed', 'vulnerabilities': len(vulnerabilities)}
                except json.JSONDecodeError:
                    pass

            print(f"{Colors.OKGREEN}    âœ“ No vulnerable dependencies found{Colors.ENDC}")
            return {'status': 'completed', 'vulnerabilities': 0}

        except FileNotFoundError:
            print(f"{Colors.WARNING}    âš  Safety not found. Install with: pip install safety{Colors.ENDC}")
            return {'status': 'skipped', 'reason': 'Safety not installed'}
        except Exception as e:
            print(f"{Colors.FAIL}    âœ— Error running Safety: {e}{Colors.ENDC}")
            return {'status': 'error', 'message': str(e)}

    def scan_infrastructure_code(self, iac_path: str) -> Dict:
        """
        Scan Infrastructure as Code for security misconfigurations using Checkov

        OWASP Reference: Infrastructure as Code Security
        NIST CSF: Protect (PR.IP)
        """
        print(f"\n{Colors.HEADER}[*] Scanning Infrastructure as Code (IaC){Colors.ENDC}")
        print(f"{Colors.OKBLUE}    Using Checkov - IaC Security Scanner{Colors.ENDC}")

        try:
            result = subprocess.run(
                ['checkov', '-d', iac_path, '-o', 'json',
                 '--output-file-path', str(self.output_dir)],
                capture_output=True,
                text=True
            )

            # Parse Checkov results
            checkov_file = self.output_dir / 'results_json.json'
            if checkov_file.exists():
                with open(checkov_file, 'r') as f:
                    checkov_results = json.load(f)

                failed_checks = checkov_results.get('summary', {}).get('failed', 0)
                print(f"{Colors.OKGREEN}    âœ“ Scan completed - {failed_checks} issues found{Colors.ENDC}")
                return {'status': 'completed', 'issues': failed_checks}

        except FileNotFoundError:
            print(f"{Colors.WARNING}    âš  Checkov not found. Install with: pip install checkov{Colors.ENDC}")
            return {'status': 'skipped', 'reason': 'Checkov not installed'}
        except Exception as e:
            print(f"{Colors.FAIL}    âœ— Error running Checkov: {e}{Colors.ENDC}")
            return {'status': 'error', 'message': str(e)}

    def scan_network_ports(self, target_host: str) -> Dict:
        """
        Perform network port scanning using nmap

        OWASP Reference: Network Security Testing
        NIST CSF: Detect (DE.CM)
        """
        print(f"\n{Colors.HEADER}[*] Running Network Port Scan{Colors.ENDC}")
        print(f"{Colors.OKBLUE}    Using Nmap - Network Scanner{Colors.ENDC}")

        try:
            result = subprocess.run(
                ['nmap', '-sV', '-oX', str(self.output_dir / 'nmap_scan.xml'), target_host],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                print(f"{Colors.OKGREEN}    âœ“ Port scan completed{Colors.ENDC}")
                return {'status': 'completed'}

        except FileNotFoundError:
            print(f"{Colors.WARNING}    âš  Nmap not found. Install with your package manager{Colors.ENDC}")
            return {'status': 'skipped', 'reason': 'Nmap not installed'}
        except subprocess.TimeoutExpired:
            print(f"{Colors.WARNING}    âš  Scan timeout - network may be slow{Colors.ENDC}")
            return {'status': 'timeout'}
        except Exception as e:
            print(f"{Colors.FAIL}    âœ— Error running Nmap: {e}{Colors.ENDC}")
            return {'status': 'error', 'message': str(e)}

    def scan_secrets(self, code_path: str) -> Dict:
        """
        Scan for hardcoded secrets and credentials using TruffleHog or similar

        OWASP Reference: Sensitive Data Exposure
        NIST CSF: Protect (PR.DS)
        """
        print(f"\n{Colors.HEADER}[*] Scanning for Hardcoded Secrets{Colors.ENDC}")
        print(f"{Colors.OKBLUE}    Checking for exposed credentials{Colors.ENDC}")

        # Simple pattern matching for common secrets
        dangerous_patterns = [
            'password', 'api_key', 'api-key', 'apikey',
            'secret', 'token', 'private_key', 'aws_access'
        ]

        findings = 0
        try:
            for pattern in dangerous_patterns:
                result = subprocess.run(
                    ['grep', '-r', '-i', pattern, code_path],
                    capture_output=True,
                    text=True
                )
                if result.stdout:
                    lines = result.stdout.split('\n')
                    for line in lines:
                        if '=' in line or ':' in line:  # Likely assignment
                            findings += 1
                            self.add_finding(
                                severity='CRITICAL',
                                category='Hardcoded Secrets',
                                title=f'Potential {pattern} exposure',
                                description=line[:100],
                                recommendation='Remove hardcoded secrets and use environment variables or secrets management',
                                reference='OWASP Top 10: A02:2021 â€“ Cryptographic Failures',
                                cwe='CWE-798'
                            )

            if findings > 0:
                print(f"{Colors.WARNING}    âš  Found {findings} potential secret exposures{Colors.ENDC}")
            else:
                print(f"{Colors.OKGREEN}    âœ“ No obvious secrets found{Colors.ENDC}")

            return {'status': 'completed', 'findings': findings}

        except Exception as e:
            print(f"{Colors.FAIL}    âœ— Error scanning for secrets: {e}{Colors.ENDC}")
            return {'status': 'error', 'message': str(e)}

    def add_finding(self, severity: str, category: str, title: str,
                    description: str, recommendation: str, reference: str,
                    cwe: str = 'N/A'):
        """Add a finding to the results"""
        finding = {
            'severity': severity,
            'category': category,
            'title': title,
            'description': description,
            'recommendation': recommendation,
            'reference': reference,
            'cwe': cwe,
            'timestamp': datetime.now().isoformat()
        }

        self.results['findings'][severity.lower()].append(finding)
        self.results['statistics']['total_vulnerabilities'] += 1

    def _map_severity(self, severity: str) -> str:
        """Map various severity levels to standard categories"""
        severity_map = {
            'CRITICAL': 'critical',
            'HIGH': 'high',
            'MEDIUM': 'medium',
            'LOW': 'low',
            'INFO': 'info',
            'INFORMATIONAL': 'info'
        }
        return severity_map.get(severity.upper(), 'medium')

    def generate_report(self) -> str:
        """Generate comprehensive HTML security report"""
        print(f"\n{Colors.HEADER}[*] Generating Security Assessment Report{Colors.ENDC}")

        # Calculate statistics
        for severity in ['critical', 'high', 'medium', 'low', 'info']:
            self.results['statistics']['by_severity'][severity] = len(
                self.results['findings'][severity]
            )

        # Generate HTML report
        html_report = self._generate_html_report()
        report_path = self.output_dir / f"security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"

        with open(report_path, 'w') as f:
            f.write(html_report)

        # Generate JSON report
        json_path = self.output_dir / f"security_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(json_path, 'w') as f:
            json.dump(self.results, f, indent=2)

        print(f"{Colors.OKGREEN}    âœ“ HTML Report: {report_path}{Colors.ENDC}")
        print(f"{Colors.OKGREEN}    âœ“ JSON Report: {json_path}{Colors.ENDC}")

        return str(report_path)

    def _generate_html_report(self) -> str:
        """Generate HTML security report"""
        stats = self.results['statistics']

        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Security Assessment Report - {self.target}</title>
    <style>
        body {{ font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .header {{ background: linear-gradient(135deg, #d32f2f 0%, #c62828 100%); color: white; padding: 30px; border-radius: 5px; }}
        .header h1 {{ margin: 0; font-size: 2.5em; }}
        .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin: 20px 0; }}
        .summary-card {{ background: white; padding: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); text-align: center; }}
        .summary-number {{ font-size: 2.5em; font-weight: bold; margin: 10px 0; }}
        .critical {{ color: #d32f2f; }}
        .high {{ color: #f57c00; }}
        .medium {{ color: #fbc02d; }}
        .low {{ color: #388e3c; }}
        .info {{ color: #1976d2; }}
        .findings {{ background: white; margin: 20px 0; padding: 20px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        .finding {{ border-left: 4px solid #ccc; padding: 15px; margin: 10px 0; background: #f9f9f9; }}
        .finding.critical {{ border-color: #d32f2f; background: #ffebee; }}
        .finding.high {{ border-color: #f57c00; background: #fff3e0; }}
        .finding.medium {{ border-color: #fbc02d; background: #fffde7; }}
        .severity-badge {{ padding: 5px 12px; border-radius: 3px; font-weight: bold; font-size: 0.85em; display: inline-block; }}
        .severity-critical {{ background: #d32f2f; color: white; }}
        .severity-high {{ background: #f57c00; color: white; }}
        .severity-medium {{ background: #fbc02d; color: #000; }}
        .severity-low {{ background: #388e3c; color: white; }}
        .severity-info {{ background: #1976d2; color: white; }}
        .footer {{ text-align: center; color: #666; margin: 30px 0; }}
        a {{ color: #1976d2; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ”’ Security Assessment Report</h1>
        <p>Target: {self.target}</p>
        <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>

    <div class="summary">
        <div class="summary-card">
            <div>Total Vulnerabilities</div>
            <div class="summary-number">{stats['total_vulnerabilities']}</div>
        </div>
        <div class="summary-card">
            <div class="summary-number critical">{stats['by_severity']['critical']}</div>
            <div>Critical</div>
        </div>
        <div class="summary-card">
            <div class="summary-number high">{stats['by_severity']['high']}</div>
            <div>High</div>
        </div>
        <div class="summary-card">
            <div class="summary-number medium">{stats['by_severity']['medium']}</div>
            <div>Medium</div>
        </div>
        <div class="summary-card">
            <div class="summary-number low">{stats['by_severity']['low']}</div>
            <div>Low</div>
        </div>
    </div>
"""

        # Add findings by severity
        for severity in ['critical', 'high', 'medium', 'low', 'info']:
            findings = self.results['findings'][severity]
            if findings:
                html += f"""
    <div class="findings">
        <h2>{severity.upper()} Severity Findings ({len(findings)})</h2>
"""
                for finding in findings:
                    html += f"""
        <div class="finding {severity}">
            <span class="severity-badge severity-{severity}">{severity.upper()}</span>
            <h3>{finding['title']}</h3>
            <p><strong>Category:</strong> {finding['category']}</p>
            <p><strong>Description:</strong> {finding['description']}</p>
            <p><strong>Recommendation:</strong> {finding['recommendation']}</p>
            <p><strong>Reference:</strong> {finding['reference']}</p>
            <p><strong>CWE:</strong> {finding['cwe']}</p>
        </div>
"""
                html += "    </div>"

        html += """
    <div class="footer">
        <p><strong>Vulnerability Scanner v1.0</strong></p>
        <p>Based on OWASP and NIST Cybersecurity Framework Best Practices</p>
        <p>
            <a href="https://owasp.org/www-project-web-security-testing-guide/" target="_blank">OWASP WSTG</a> |
            <a href="https://www.nist.gov/cyberframework" target="_blank">NIST CSF</a> |
            <a href="https://owasp.org/www-community/Vulnerability_Scanning_Tools" target="_blank">OWASP Scanning Tools</a>
        </p>
    </div>
</body>
</html>
"""
        return html

    def print_summary(self):
        """Print scan summary to console"""
        stats = self.results['statistics']

        print(f"\n{Colors.HEADER}{'='*70}{Colors.ENDC}")
        print(f"{Colors.BOLD}Security Assessment Summary{Colors.ENDC}")
        print(f"{Colors.HEADER}{'='*70}{Colors.ENDC}\n")

        print(f"Total Vulnerabilities Found: {Colors.BOLD}{stats['total_vulnerabilities']}{Colors.ENDC}\n")

        print(f"{Colors.FAIL}Critical: {stats['by_severity']['critical']}{Colors.ENDC}")
        print(f"{Colors.WARNING}High:     {stats['by_severity']['high']}{Colors.ENDC}")
        print(f"{Colors.WARNING}Medium:   {stats['by_severity']['medium']}{Colors.ENDC}")
        print(f"{Colors.OKGREEN}Low:      {stats['by_severity']['low']}{Colors.ENDC}")
        print(f"{Colors.OKBLUE}Info:     {stats['by_severity']['info']}{Colors.ENDC}")


def main():
    parser = argparse.ArgumentParser(
        description='Comprehensive Vulnerability Scanner based on OWASP and NIST best practices',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Scan Python code for vulnerabilities
  %(prog)s --code-path /path/to/code --scan-code

  # Scan dependencies for known vulnerabilities
  %(prog)s --code-path /path/to/code --scan-dependencies

  # Run all scans
  %(prog)s --code-path /path/to/code --all

  # Scan infrastructure as code
  %(prog)s --iac-path /path/to/terraform --scan-iac

References:
  - OWASP Web Security Testing Guide: https://owasp.org/www-project-web-security-testing-guide/
  - NIST Cybersecurity Framework: https://www.nist.gov/cyberframework
        """
    )

    parser.add_argument('--code-path', help='Path to code to scan')
    parser.add_argument('--iac-path', help='Path to Infrastructure as Code')
    parser.add_argument('--requirements', help='Path to requirements.txt file')
    parser.add_argument('--network-target', help='Target host for network scan')
    parser.add_argument('--output-dir', default='scan_results', help='Output directory for results')

    parser.add_argument('--scan-code', action='store_true', help='Run code security scan (SAST)')
    parser.add_argument('--scan-dependencies', action='store_true', help='Run dependency scan (SCA)')
    parser.add_argument('--scan-iac', action='store_true', help='Run IaC security scan')
    parser.add_argument('--scan-network', action='store_true', help='Run network port scan')
    parser.add_argument('--scan-secrets', action='store_true', help='Scan for hardcoded secrets')
    parser.add_argument('--all', action='store_true', help='Run all applicable scans')

    args = parser.parse_args()

    if not any([args.scan_code, args.scan_dependencies, args.scan_iac,
                args.scan_network, args.scan_secrets, args.all]):
        parser.print_help()
        sys.exit(1)

    target = args.code_path or args.iac_path or args.network_target or 'local'
    scanner = VulnerabilityScanner(target, args.output_dir)
    scanner.print_banner()

    # Run requested scans
    if (args.scan_code or args.all) and args.code_path:
        scanner.scan_code_security(args.code_path)

    if (args.scan_dependencies or args.all):
        scanner.scan_dependencies(args.requirements)

    if (args.scan_iac or args.all) and args.iac_path:
        scanner.scan_infrastructure_code(args.iac_path)

    if (args.scan_network or args.all) and args.network_target:
        scanner.scan_network_ports(args.network_target)

    if (args.scan_secrets or args.all) and args.code_path:
        scanner.scan_secrets(args.code_path)

    # Generate reports
    report_path = scanner.generate_report()
    scanner.print_summary()

    print(f"\n{Colors.OKGREEN}Scan completed successfully!{Colors.ENDC}")
    print(f"Full report available at: {Colors.BOLD}{report_path}{Colors.ENDC}\n")


if __name__ == '__main__':
    main()
